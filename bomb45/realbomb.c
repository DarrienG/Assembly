//
// This file was generated by the Retargetable Decompiler
// Website: https://retdec.com
// Copyright (c) 2015 Retargetable Decompiler <info@retdec.com>
//

#include <ctype.h>
#include <netdb.h>
#include <signal.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <unistd.h>

// ------------------------ Structures ------------------------

struct _IO_FILE {
    struct _IO_FILE * e0;
    int32_t e1;
    int32_t e2;
    int32_t e3;
    int16_t e4;
    char e5;
    char e6[1];
    char * e7;
    int64_t e8;
    char * e9;
    char * e10;
    char * e11;
    char * e12;
    int32_t e13;
    int32_t e14;
    char e15[40];
};

struct sockaddr {
    int16_t e0;
    char e1[14];
};

struct struct_1 {
    int32_t e0;
    int32_t e1;
    int32_t e2;
};

struct struct_2 {
    char e0;
    char e1[2];
};

struct struct__IO_FILE {
    int32_t e0;
    char * e1;
    char * e2;
    char * e3;
    char * e4;
    char * e5;
    char * e6;
    char * e7;
    char * e8;
    char * e9;
    char * e10;
    char * e11;
    struct struct__IO_marker * e12;
    struct struct__IO_FILE * e13;
    int32_t e14;
    int32_t e15;
    int32_t e16;
    int16_t e17;
    char e18;
    char e19[1];
    char * e20;
    int64_t e21;
    char * e22;
    char * e23;
    char * e24;
    char * e25;
    int32_t e26;
    int32_t e27;
    char e28[40];
};

struct struct__IO_marker {
    struct struct__IO_marker * e0;
    struct struct__IO_FILE * e1;
    int32_t e2;
};

// ------------------- Function Prototypes --------------------

void blank_line(void);
void explode_bomb(void);
void fun6(void);
void fun7(void);
void func4(void);
void initialize_bomb(void);
void open_clientfd(void);
void phase_1(void);
void phase_2(void);
void phase_3(void);
void phase_4(void);
void phase_5(void);
void phase_6(void);
void phase_defused(void);
void read_line(void);
void read_six_numbers(void);
void secret_phase(void);
void send_msg(void);
int32_t sig_handler(int32_t a1);
void skip(void);
void string_length(void);
void strings_not_equal(void);

// --------------------- Global Variables ---------------------

int32_t g1 = 0; // eax
int32_t g2 = 0; // ebx
int32_t g3 = 0; // edi
int32_t g4 = 0; // esi
int32_t g5 = 45; // 0x804a1a0
int32_t g6 = 0; // 0x804a62c
char * g7[2] = {
    "mercury.cs.uml.edu",
    "mercury"
}; // 0x804a700
int32_t g8 = 0; // 0x804a840
int32_t g9 = 0; // 0x804a860
int32_t g10 = 0; // 0x804a86c
struct _IO_FILE * infile; // 0x804a870

// ------------------------ Functions -------------------------

// From module:   /usr/cs/fac1/bomb/bomblab/src/bomb.c
// Address range: 0x80489f4 - 0x8048b4f
// Line range:    36 - 114
int main(int argc, char ** argv) {
    int32_t v1 = (int32_t)argv; // 0x8048a02_1
    g4 = v1;
    int32_t puts_rc6; // 0x8048b29
    int32_t puts_rc; // 0x8048a93
    int32_t puts_rc2; // 0x8048ab1
    int32_t puts_rc3; // 0x8048acf
    int32_t puts_rc4; // 0x8048aed
    int32_t puts_rc5; // 0x8048b0b
    int32_t file_path;
    if ((char *)argc == (char *)1) {
        // 0x8048a0a
        infile = (struct _IO_FILE *)g8;
        // branch -> 0x8048a7b
        // 0x8048a7b
        initialize_bomb();
        file_path = (int32_t)"Welcome to my fiendish little bomb. You have 6 phases with";
        puts("Welcome to my fiendish little bomb. You have 6 phases with");
        file_path = (int32_t)"which to blow yourself up. Have a nice day!";
        puts_rc = puts("which to blow yourself up. Have a nice day!");
        read_line();
        file_path = puts_rc;
        phase_1();
        phase_defused();
        file_path = (int32_t)"Phase 1 defused. How about the next one?";
        puts_rc2 = puts("Phase 1 defused. How about the next one?");
        read_line();
        file_path = puts_rc2;
        phase_2();
        phase_defused();
        file_path = (int32_t)"That's number 2.  Keep going!";
        puts_rc3 = puts("That's number 2.  Keep going!");
        read_line();
        file_path = puts_rc3;
        phase_3();
        phase_defused();
        file_path = (int32_t)"Halfway there!";
        puts_rc4 = puts("Halfway there!");
        read_line();
        file_path = puts_rc4;
        phase_4();
        phase_defused();
        file_path = (int32_t)"So you got that one.  Try this one.";
        puts_rc5 = puts("So you got that one.  Try this one.");
        read_line();
        file_path = puts_rc5;
        phase_5();
        phase_defused();
        file_path = (int32_t)"Good work!  On to the next...";
        puts_rc6 = puts("Good work!  On to the next...");
        read_line();
        file_path = puts_rc6;
        phase_6();
        phase_defused();
        return 0;
    }
    // 0x8048a16
    int32_t v2;
    if (argc != 2) {
        // 0x8048a5d
        v2 = *(int32_t *)argv;
        file_path = (int32_t)"Usage: %s [<input_file>]\n";
        printf("Usage: %s [<input_file>]\n", &v2);
        file_path = 8;
        exit(8);
        // UNREACHABLE
    }
    int32_t v3 = v1 + 4; // 0x8048a1b
    g2 = v3;
    v2 = (int32_t)"r";
    file_path = *(int32_t *)v3;
    struct struct__IO_FILE * file = fopen((char *)&file_path, "r"); // 0x8048a2b
    infile = (struct _IO_FILE *)file;
    if (file == NULL) {
        int32_t v4 = *(int32_t *)g2;
        v2 = *(int32_t *)g4;
        file_path = (int32_t)"%s: Error: Couldn't open %s\n";
        printf("%s: Error: Couldn't open %s\n", &v2, &v4);
        file_path = 8;
        exit(8);
        // UNREACHABLE
    }
    // 0x8048a7b
    initialize_bomb();
    file_path = (int32_t)"Welcome to my fiendish little bomb. You have 6 phases with";
    puts("Welcome to my fiendish little bomb. You have 6 phases with");
    file_path = (int32_t)"which to blow yourself up. Have a nice day!";
    puts_rc = puts("which to blow yourself up. Have a nice day!");
    read_line();
    file_path = puts_rc;
    phase_1();
    phase_defused();
    file_path = (int32_t)"Phase 1 defused. How about the next one?";
    puts_rc2 = puts("Phase 1 defused. How about the next one?");
    read_line();
    file_path = puts_rc2;
    phase_2();
    phase_defused();
    file_path = (int32_t)"That's number 2.  Keep going!";
    puts_rc3 = puts("That's number 2.  Keep going!");
    read_line();
    file_path = puts_rc3;
    phase_3();
    phase_defused();
    file_path = (int32_t)"Halfway there!";
    puts_rc4 = puts("Halfway there!");
    read_line();
    file_path = puts_rc4;
    phase_4();
    phase_defused();
    file_path = (int32_t)"So you got that one.  Try this one.";
    puts_rc5 = puts("So you got that one.  Try this one.");
    read_line();
    file_path = puts_rc5;
    phase_5();
    phase_defused();
    file_path = (int32_t)"Good work!  On to the next...";
    puts_rc6 = puts("Good work!  On to the next...");
    read_line();
    file_path = puts_rc6;
    phase_6();
    phase_defused();
    return 0;
}

// Address range: 0x8048b50 - 0x8048b77
void func4(void) {
    int32_t v1 = g2; // 0x8048b53
    uint32_t v2;
    g2 = v2;
    g1 = 1;
    if (v2 >= 2) {
        // 0x8048b64
        func4();
        g1 *= g2;
        // branch -> 0x8048b72
    }
    // 0x8048b72
    g2 = v1;
}

// Address range: 0x8048b78 - 0x8048bd3
void fun6(void) {
    // 0x8048b78
    int32_t v1;
    int32_t * v2 = (int32_t *)(v1 + 8); // 0x8048b81_0
    int32_t v3 = *v2; // esi
    *v2 = 0;
    if (v3 == 0) {
        // 0x8048bcf
        return;
    }
    int32_t v4 = v3; // 0x8048b91
    while (true) {
        int32_t v5 = 0; // 0x8048ba817
        int32_t v6; // 0x8048bb3
        int32_t v7; // 0x8048bb6
        if (v1 != 0) {
            int32_t v8 = *(int32_t *)v4; // 0x8048bc7
            if (*(int32_t *)v1 > v8) {
                int32_t v9 = *(int32_t *)(v1 + 8); // 0x8048b994
                int32_t v10 = v1;
                int32_t v11; // ecx
                int32_t v12; // 0x8048ba421
                if (v9 != 0) {
                    int32_t v13 = v1; // 0x8048ba49
                    while (true) {
                        // 0x8048ba0
                        if (*(int32_t *)v9 > v8) {
                            int32_t v14 = *(int32_t *)(v9 + 8); // 0x8048b99
                            if (v14 == 0) {
                                v10 = v9;
                                // break -> 0x8048ba8
                                break;
                            }
                            v13 = v9;
                            v9 = v14;
                            // continue -> 0x8048ba0
                            continue;
                        } else {
                            // 0x8048ba8
                            v11 = v9;
                            if (v13 == v9) {
                                // 0x8048bac
                                v7 = v13;
                                v6 = v4;
                                // branch -> 0x8048bb3
                              lab_0x8048bb3_2:;
                                int32_t * v15 = (int32_t *)(v6 + 8); // 0x8048bb3_0
                                *v15 = v7;
                                int32_t v16 = *v15; // 0x8048bb9
                                if (v16 == 0) {
                                    // 0x8048bcf
                                    return;
                                }
                                // 0x8048bbd
                                v3 = v16;
                                v4 = v16;
                                // branch -> 0x8048bc3
                                break;
                            } else {
                                v12 = v13;
                            }
                        }
                      lab_0x8048bb0_2:
                        // 0x8048bb0
                        *(int32_t *)(v12 + 8) = v4;
                        v7 = v11;
                        v6 = v3;
                        // branch -> 0x8048bb3
                        goto lab_0x8048bb3_2;
                    }
                    // 0x8048ba8
                    v11 = 0;
                    v12 = v10;
                    // branch -> 0x8048bb0
                    goto lab_0x8048bb0_2;
                }
                // 0x8048ba8
                v11 = 0;
                v12 = v10;
                // branch -> 0x8048bb0
                goto lab_0x8048bb0_2;
            } else {
                v5 = v1;
            }
        }
        // 0x8048bac
        v7 = v5;
        v6 = v4;
        // branch -> 0x8048bb3
        goto lab_0x8048bb3_2;
    }
}

// Address range: 0x8048bd4 - 0x8048c24
void fun7(void) {
    int32_t v1 = g2; // 0x8048bd7
    g1 = -1;
    struct struct_1 * v2;
    if (v2 == NULL) {
        // 0x8048c1f
        g2 = v1;
        return;
    }
    int32_t v3 = v2->e0; // 0x8048bea
    g2 = v3;
    int32_t v4;
    if (v3 > v4) {
        // 0x8048bf0
        fun7();
        g1 *= 2;
        // branch -> 0x8048c1f
        // 0x8048c1f
        g2 = v1;
        return;
    }
    // 0x8048c03
    g1 = 0;
    if (v3 != v4) {
        // 0x8048c0c
        fun7();
        g1 = 2 * g1 | 1;
        // branch -> 0x8048c1f
    }
    // 0x8048c1f
    g2 = v1;
}

// Address range: 0x8048c25 - 0x8048c8a
void secret_phase(void) {
    int32_t v1 = g2; // 0x8048c28
    read_line();
    char * endptr = NULL; // bp-24
    int32_t str_as_l = strtol((char *)g1, &endptr, 10); // 0x8048c44
    g2 = str_as_l;
    int32_t v2 = str_as_l; // 0x8048c5a
    if (str_as_l >= 1002) {
        // 0x8048c55
        explode_bomb();
        v2 = g2;
        // branch -> 0x8048c5a
    }
    // 0x8048c5a
    endptr = (char *)v2;
    fun7();
    if (g1 != 4) {
        // 0x8048c6f
        explode_bomb();
        // branch -> 0x8048c74
    }
    // 0x8048c74
    puts("Wow! You've defused the secret stage!");
    phase_defused();
    g2 = v1;
}

// Address range: 0x8048c8b - 0x8048cd8
void phase_6(void) {
    int32_t v1 = g2; // 0x8048c8e
    char * endptr = NULL; // bp-24
    int32_t ** str;
    int32_t str_as_l = strtol((char *)str, &endptr, 10); // 0x8048ca8
    g2 = 0x804a62c;
    g6 = str_as_l;
    fun6();
    int32_t v2 = *(int32_t *)(*(int32_t *)(str_as_l + 8) + 8); // 0x8048cbf
    int32_t v3 = *(int32_t *)(*(int32_t *)(v2 + 8) + 8); // 0x8048cc5
    if (*(int32_t *)v3 != g6) {
        // 0x8048cce
        explode_bomb();
        // branch -> 0x8048cd3
    }
    // 0x8048cd3
    g2 = v1;
}

// Address range: 0x8048cd9 - 0x8048d46
void phase_5(void) {
    int32_t v1 = g4; // 0x8048cdd
    int32_t v2 = g2; // 0x8048cde
    string_length();
    if (g1 != 6) {
        // 0x8048cf2
        explode_bomb();
        // branch -> 0x8048cf7
    }
    int32_t v3 = 0; // eax
    int32_t v4 = 0;
    // branch -> 0x8048d04
    while (true) {
        // 0x8048d04
        char * v5;
        unsigned char v6 = *(char *)((int32_t)(v5[v4] % 16) + 0x80498c0); // 0x8048d0e
        int32_t v7 = v6; // 0x8048d0e
        g4 = v7;
        g2 = v7;
        char * v8;
        v8[v4] = v6;
        int32_t v9 = v3 + 1; // 0x8048d17
        v3 = v9;
        if (v9 == 6) {
            // 0x8048d1f
            strings_not_equal();
            if (g1 != 0) {
                // 0x8048d3a
                explode_bomb();
                // branch -> 0x8048d3f
            }
            // 0x8048d3f
            g2 = v2;
            g4 = v1;
            return;
        }
        // 0x8048d04
        v4 = v9;
        // branch -> 0x8048d04
    }
}

// Address range: 0x8048d47 - 0x8048d6a
void phase_1(void) {
    // 0x8048d47
    strings_not_equal();
    if (g1 != 0) {
        // 0x8048d64
        explode_bomb();
        // branch -> 0x8048d69
    }
}

// Address range: 0x8048d6b - 0x8048db3
void phase_4(void) {
    char * str;
    char * v1;
    if (sscanf(str, "%d", &v1) != 1) {
        // 0x8048d96
        explode_bomb();
        // branch -> 0x8048d9b
        // 0x8048d9b
        func4();
        if (g1 != 0x13b0) {
            // 0x8048dad
            explode_bomb();
            // branch -> 0x8048db2
        }
        // 0x8048db2
        return;
    }
    // 0x8048d90
    if (v1 <= NULL) {
        // 0x8048d96
        explode_bomb();
        // branch -> 0x8048d9b
    }
    // 0x8048d9b
    func4();
    if (g1 != 0x13b0) {
        // 0x8048dad
        explode_bomb();
        // branch -> 0x8048db2
    }
}

// Address range: 0x8048db4 - 0x8048e69
void phase_3(void) {
    char * str;
    int32_t v1;
    int32_t v2;
    if (sscanf(str, "%d %d", &v1, &v2) <= 1) {
        // 0x8048de0
        explode_bomb();
        // branch -> 0x8048de5
    }
    int32_t v3 = v1; // 0x8048de5
    switch (v3) {
        default: {
            // 0x8048e4e
            explode_bomb();
            // branch -> 0x8048e58
            // 0x8048e58
            if (v1 >= 6 || 0 != v2) {
                // 0x8048e63
                explode_bomb();
                // branch -> 0x8048e68
            }
            // 0x8048e68
            return;
        }
        case 0: {
            // 0x8048e2b
            // branch -> 0x8048e2e
            // 0x8048e2e
            // branch -> 0x8048e33
            // 0x8048e33
            // branch -> 0x8048e38
            // 0x8048e38
            // branch -> 0x8048e3d
            // 0x8048e3d
            // branch -> 0x8048e42
            // 0x8048e42
            // branch -> 0x8048e47
            // 0x8048e47
            // branch -> 0x8048e58
            // 0x8048e58
            if (v3 >= 6 || -13 != v2) {
                // 0x8048e63
                explode_bomb();
                // branch -> 0x8048e68
            }
            // 0x8048e68
            return;
        }
        case 1: {
            // 0x8048e26
            // branch -> 0x8048e2b
            break;
        }
        case 2: {
            // 0x8048e2e
            // branch -> 0x8048e33
        }
        case 3: {
            // 0x8048e33
            // branch -> 0x8048e38
        }
        case 4: {
            // 0x8048e38
            // branch -> 0x8048e3d
        }
        case 5: {
            // 0x8048e3d
            // branch -> 0x8048e42
        }
        case 6: {
            // 0x8048e42
            // branch -> 0x8048e47
        }
        case 7: {
            // 0x8048e47
            // branch -> 0x8048e58
            // 0x8048e58
            if (v3 >= 6 || -250 != v2) {
                // 0x8048e63
                explode_bomb();
                // branch -> 0x8048e68
            }
            // 0x8048e68
            return;
        }
    }
    // 0x8048e2b
    // branch -> 0x8048e2e
    // 0x8048e2e
    // branch -> 0x8048e33
    // 0x8048e33
    // branch -> 0x8048e38
    // 0x8048e38
    // branch -> 0x8048e3d
    // 0x8048e3d
    // branch -> 0x8048e42
    // 0x8048e42
    // branch -> 0x8048e47
    // 0x8048e47
    // branch -> 0x8048e58
    // 0x8048e58
    if (v3 >= 6 || -164 != v2) {
        // 0x8048e63
        explode_bomb();
        // branch -> 0x8048e68
    }
}

// Address range: 0x8048e6a - 0x8048ebf
void phase_2(void) {
    int32_t v1 = g4; // 0x8048e6d
    int32_t v2 = g2; // 0x8048e6e
    int32_t v3;
    int32_t v4 = &v3; // 0x8048e72_0
    read_six_numbers();
    if (v3 != 1) {
        // 0x8048e8a
        explode_bomb();
        // branch -> 0x8048e8f
    }
    // 0x8048e8f
    g4 = v4;
    int32_t v5 = 1; // 0x8048e97
    // branch -> 0x8048e97
    while (true) {
        int32_t v6 = v5 + 1; // 0x8048e99
        g2 = v6;
        int32_t v7 = 4 * v5; // 0x8048e9e
        int32_t v8 = *(int32_t *)(v4 - 4 + v7); // 0x8048e9e
        int32_t v9 = v6; // 0x8048ead
        if (*(int32_t *)(v7 + v4) != v8 * v6) {
            // 0x8048ea8
            explode_bomb();
            v9 = g2;
            // branch -> 0x8048ead
        }
        // 0x8048ead
        if (v9 == 6) {
            // 0x8048eb2
            g2 = v2;
            g4 = v1;
            return;
        }
        // 0x8048ead
        v4 = g4;
        v5 = v9;
        // branch -> 0x8048e97
    }
}

// Address range: 0x8048ec0 - 0x8048eda
void string_length(void) {
    g1 = 0;
    struct struct_2 * v1;
    if (v1->e0 == 0) {
        // 0x8048ed9
        return;
    }
    int32_t v2 = 1; // 0x8048ed0
    g1 = v2;
    while (*(char *)(v2 + (int32_t)v1) != 0) {
        // 0x8048ed0
        v2++;
        g1 = v2;
        // continue -> 0x8048ed0
    }
}

// Address range: 0x8048edb - 0x8048f3c
void strings_not_equal(void) {
    // 0x8048edb
    struct struct_2 * v1;
    int32_t v2 = (int32_t)v1; // ebx
    struct struct_2 * v3;
    int32_t v4 = (int32_t)v3; // esi
    string_length();
    string_length();
    unsigned char v5 = *(char *)v2; // 0x8048f00
    int32_t v6;
    if (v5 != 0) {
        // 0x8048f07
        if ((int32_t)v5 == (int32_t)*(char *)v4) {
            int32_t v7 = 0; // 0x8048f17
            // branch -> 0x8048f1e
            while (true) {
                char v8 = *(char *)(v2 + 1 + v7); // 0x8048f1e
                if (v8 != 0) {
                    // 0x8048f12
                    if (v8 != *(char *)(v4 + 1 + v7)) {
                        // break -> 0x8048f35
                        break;
                    }
                    v7++;
                    // continue -> 0x8048f1e
                    continue;
                }
                // 0x8048f35
                g1 = 0;
                return;
            }
            // 0x8048f35
            g1 = 1;
            return;
        }
        v6 = 1;
    } else {
        v6 = 0;
    }
    // 0x8048f35
    g1 = v6;
}

// Address range: 0x8048f3d - 0x8049195
void send_msg(void) {
    int32_t v1 = g3; // 0x8048f40
    int32_t v2 = g4; // 0x8048f41
    int32_t v3 = g2; // 0x8048f42
    int32_t fd = dup(0); // 0x8048f50
    if (fd == -1) {
        // 0x8048f5d
        puts("ERROR: dup(0) error");
        exit(8);
        // UNREACHABLE
    }
    // 0x8048f75
    if (close(0) == -1) {
        // 0x8048f86
        puts("ERROR: close error");
        exit(8);
        // UNREACHABLE
    }
    struct struct__IO_FILE * tmp_file = tmpfile(); // 0x8048f9e
    if (tmp_file == NULL) {
        // 0x8048fa9
        puts("ERROR: tmpfile error");
        exit(8);
        // UNREACHABLE
    }
    // 0x8048fc1
    fwrite("Subject: Bomb notification\n", 1, 27, tmp_file);
    fputc(10, tmp_file);
    char * str2 = cuserid(NULL); // 0x8048ff8
    int32_t str;
    if (str2 == NULL) {
        // 0x8049001
        str = 0x6f626f6e;
        // branch -> 0x8049025
    } else {
        // 0x8049016
        strcpy((char *)&str, str2);
        // branch -> 0x8049025
    }
    // 0x8049025
    char * v4;
    if (v4 != NULL) {
        // if_8049033_0_true
        // branch -> after_if_8049033_0
    }
    int32_t v5 = g10;
    fprintf(tmp_file, "bomb-header:%s:%d:%s:%s:%d\n", "Fall15bomb", g5, &str, "defused", g10);
    if (g10 < 1) {
        // 0x80490bd
        rewind(tmp_file);
        sprintf((char *)0x804aec0, "%s %s@%s", "/usr/sbin/sendmail -bm", "bomb", "cs.uml.edu");
        if (system((char *)0x804aec0) != 0) {
            // 0x8049101
            puts("ERROR: notification error");
            exit(8);
            // UNREACHABLE
        }
        // 0x8049119
        if (fclose(tmp_file) != 0) {
            // 0x8049125
            puts("ERROR: fclose(tmp) error");
            exit(8);
            // UNREACHABLE
        }
        // 0x804913d
        if (dup(fd) != 0) {
            // 0x804914c
            puts("ERROR: dup(tmpstdin) error");
            exit(8);
            // UNREACHABLE
        }
        // 0x8049164
        if (close(fd) != 0) {
            // 0x8049173
            puts("ERROR: close(tmpstdin)");
            exit(8);
            // UNREACHABLE
        }
        // 0x804918b
        g2 = v3;
        g4 = v2;
        g3 = v1;
        return;
    }
    // 0x8049075
    g4 = 0x804a880;
    int32_t v6 = 1; // 0x804907f
    g2 = v6;
    v5 = 0x804a880;
    fprintf(tmp_file, "bomb-string:%s:%d:%s:%d:%s\n", "Fall15bomb", g5, &str, v6, &v5);
    int32_t v7 = g4 + 80; // 0x80490b2
    g4 = v7;
    int32_t v8 = g2; // 0x80490b5
    // branch -> 0x804907f
    while (g10 > v8) {
        // 0x804907f
        v6 = v8 + 1;
        g2 = v6;
        v5 = v7;
        fprintf(tmp_file, "bomb-string:%s:%d:%s:%d:%s\n", "Fall15bomb", g5, &str, v6, &v5);
        v7 = g4 + 80;
        g4 = v7;
        v8 = g2;
        // continue -> 0x804907f
    }
    // 0x80490bd
    rewind(tmp_file);
    sprintf((char *)0x804aec0, "%s %s@%s", "/usr/sbin/sendmail -bm", "bomb", "cs.uml.edu");
    if (system((char *)0x804aec0) != 0) {
        // 0x8049101
        puts("ERROR: notification error");
        exit(8);
        // UNREACHABLE
    }
    // 0x8049119
    if (fclose(tmp_file) != 0) {
        // 0x8049125
        puts("ERROR: fclose(tmp) error");
        exit(8);
        // UNREACHABLE
    }
    // 0x804913d
    if (dup(fd) != 0) {
        // 0x804914c
        puts("ERROR: dup(tmpstdin) error");
        exit(8);
        // UNREACHABLE
    }
    // 0x8049164
    if (close(fd) != 0) {
        // 0x8049173
        puts("ERROR: close(tmpstdin)");
        exit(8);
        // UNREACHABLE
    }
    // 0x804918b
    g2 = v3;
    g4 = v2;
    g3 = v1;
}

// Address range: 0x8049196 - 0x8049225
void phase_defused(void) {
    int32_t str = 1; // bp-124
    send_msg();
    if (g10 == 6) {
        // 0x80491b1
        str = 0x804a970;
        int32_t v1;
        int32_t v2;
        if (sscanf((char *)&str, "%d %s", &v2, &v1) == 2) {
            // 0x80491d8
            strings_not_equal();
            if (g1 == 0) {
                // 0x80491ef
                str = (int32_t)"Curses, you've found the secret phase!";
                puts("Curses, you've found the secret phase!");
                str = (int32_t)"But finding it and solving it are quite different...";
                puts("But finding it and solving it are quite different...");
                secret_phase();
                // branch -> 0x804920c
            }
        }
        // 0x804920c
        str = (int32_t)"Congratulations! You've defused the bomb!";
        puts("Congratulations! You've defused the bomb!");
        str = (int32_t)"Your instructor has been notified and will verify your solution.";
        puts("Your instructor has been notified and will verify your solution.");
        // branch -> 0x8049224
    }
}

// Address range: 0x8049226 - 0x8049267
void explode_bomb(void) {
    // 0x8049226
    puts("\nBOOM!!!");
    puts("The bomb has blown up.");
    send_msg();
    puts("Your instructor has been notified.");
    exit(8);
    // UNREACHABLE
}

// Address range: 0x8049268 - 0x80492b6
void read_six_numbers(void) {
    // 0x8049268
    char * v1;
    int32_t v2 = (int32_t)v1; // 0x804926e
    char * v3 = (char *)(v2 + 20); // bp-16
    char * v4 = (char *)(v2 + 16); // bp-20
    char * v5 = (char *)(v2 + 12); // bp-24
    char * v6 = (char *)(v2 + 8); // bp-28
    char * v7 = (char *)(v2 + 4); // bp-32
    char * str;
    uint32_t items_assigned = sscanf(str, "%d %d %d %d %d %d", &v1, &v7, &v6, &v5, &v4, &v3); // 0x80492a6
    if (items_assigned <= 5) {
        // 0x80492b0
        explode_bomb();
        // branch -> 0x80492b5
    }
}

// Address range: 0x80492b7 - 0x80492eb
void blank_line(void) {
    char * v1;
    int32_t v2 = (int32_t)*v1; // 0x80492bc_0
    int32_t v3 = v2; // esi
    unsigned char v4 = v1[v2]; // 0x80492dc6
    if (v4 == 0) {
        // 0x80492e8
        return;
    }
    int32_t v5 = v4; // ebx
    while (true) {
        // 0x80492c1
        __ctype_b_loc();
        int32_t v6 = *(int32_t *)g1; // 0x80492c9
        g1 = v6;
        if (*(char *)(v6 + 1 + 0x1000000 * v5 / 0x800000) == 32) {
            // 0x80492e8
            return;
        }
        int32_t v7 = v3 + 1; // 0x80492d9
        v3 = v7;
        unsigned char v8 = v1[v7]; // 0x80492dc
        v5 = v8;
        if (v8 == 0) {
            // break -> 0x80492e8
            break;
        }
        // continue -> 0x80492c1
    }
}

// Address range: 0x80492ec - 0x8049335
void skip(void) {
    int32_t str = 80 * g10 + 0x804a880; // 0x804930f3
    if (fgets((char *)str, 80, (struct struct__IO_FILE *)infile) == NULL) {
        // 0x804932e
        return;
    }
    g1 = str;
    blank_line();
    int32_t str2 = 80 * g10 + 0x804a880; // 0x804930f
    while (fgets((char *)str2, 80, (struct struct__IO_FILE *)infile) != NULL) {
        // 0x8049322
        g1 = str2;
        blank_line();
        str2 = 80 * g10 + 0x804a880;
        // continue -> 0x8049322
    }
}

// Address range: 0x8049336 - 0x8049413
void read_line(void) {
    int32_t v1 = g3; // 0x8049339
    int32_t v2 = g2; // 0x804933a
    skip();
    int32_t len; // 0x80493c2
    int32_t v3; // 0x80493df
    int32_t v4; // 0x80493f1
    int32_t v5; // 0x80493f9
    if (g1 != 0) {
        // 0x80493a7
        len = strlen((char *)(80 * g10 + 0x804a880));
        g2 = len;
        v4 = len;
        if (len == 79) {
            // 0x80493ce
            puts("Error: Input line too long");
            explode_bomb();
            v4 = g2;
            // branch -> 0x80493df
        }
        // 0x80493df
        v3 = g10;
        *(char *)(v4 + 0x804a87f + 80 * v3) = 0;
        v5 = v3;
        g10 = v5 + 1;
        g1 = 16 * (4 * v3 + v5) + 0x804a880;
        g2 = v2;
        g3 = v1;
        return;
    }
    int32_t v6 = (int32_t)infile; // 0x8049347
    g1 = v6;
    if (v6 == g8) {
        // 0x8049354
        puts("Error: Premature EOF on stdin");
        explode_bomb();
        // branch -> 0x80493a7
        // 0x80493a7
        len = strlen((char *)(80 * g10 + 0x804a880));
        g2 = len;
        v4 = len;
        if (len == 79) {
            // 0x80493ce
            puts("Error: Input line too long");
            explode_bomb();
            v4 = g2;
            // branch -> 0x80493df
        }
        // 0x80493df
        v3 = g10;
        *(char *)(v4 + 0x804a87f + 80 * v3) = 0;
        v5 = v3;
        g10 = v5 + 1;
        g1 = 16 * (4 * v3 + v5) + 0x804a880;
        g2 = v2;
        g3 = v1;
        return;
    }
    // 0x8049367
    if (getenv("GRADE_BOMB") != NULL) {
        // 0x8049377
        exit(0);
        // UNREACHABLE
    }
    // 0x8049383
    infile = (struct _IO_FILE *)g8;
    skip();
    if (g1 == 0) {
        // 0x8049396
        puts("Error: Premature EOF on stdin");
        explode_bomb();
        // branch -> 0x80493a7
    }
    // 0x80493a7
    len = strlen((char *)(80 * g10 + 0x804a880));
    g2 = len;
    v4 = len;
    if (len == 79) {
        // 0x80493ce
        puts("Error: Input line too long");
        explode_bomb();
        v4 = g2;
        // branch -> 0x80493df
    }
    // 0x80493df
    v3 = g10;
    *(char *)(v4 + 0x804a87f + 80 * v3) = 0;
    v5 = v3;
    g10 = v5 + 1;
    g1 = 16 * (4 * v3 + v5) + 0x804a880;
    g2 = v2;
    g3 = v1;
}

// Address range: 0x8049439 - 0x8049493
int32_t sig_handler(int32_t a1) {
    // 0x8049439
    puts("So you think you can stop the bomb with ctrl-c, do you?");
    sleep(3);
    printf("Well...");
    int32_t stream = g9; // bp-28
    fflush((struct struct__IO_FILE *)&stream);
    stream = 1;
    sleep(1);
    stream = 0x8049a9d;
    puts("OK. :-)");
    stream = 16;
    exit(16);
    // UNREACHABLE
}

// Address range: 0x8049494 - 0x8049580
void open_clientfd(void) {
    int32_t sock_fd = socket(AF_INET, SOCK_STREAM, IPPROTO_IP); // 0x80494b3
    if (sock_fd <= 0) {
        // 0x80494be
        puts("Bad host (1).");
        exit(8);
        // UNREACHABLE
    }
    // 0x80494d6
    char * name;
    int32_t * v1 = gethostbyname(name); // 0x80494dc
    int32_t v2 = (int32_t)v1; // 0x80494e1_0
    if (v1 == NULL) {
        // 0x80494e5
        puts("Bad host (2).");
        exit(8);
        // UNREACHABLE
    }
    // 0x80494fd
    int16_t v3;
    int32_t addr = &v3; // ebx
    int32_t data = 0;
    v3 = 2;
    int32_t n = *(int32_t *)(v2 + 12); // 0x8049521
    int32_t str = *(int32_t *)(v2 + 16); // 0x804952f
    bcopy((char *)*(int32_t *)str, (char *)&data, n);
    if (connect(sock_fd, (struct sockaddr *)addr, 16) > 0) {
        // 0x8049578
        return;
    }
    // 0x8049560
    puts("Bad host (3).");
    exit(8);
    // UNREACHABLE
}

// Address range: 0x8049581 - 0x804963f
void initialize_bomb(void) {
    int32_t v1 = g3; // 0x8049584
    int32_t v2 = g4; // 0x8049585
    int32_t v3 = g2; // 0x8049586
    signal(SIGINT, (void (*)(int32_t))sig_handler);
    int32_t name;
    int32_t str2 = &name; // 0x80495a6_0
    if (gethostname((char *)&name) != 0) {
        // 0x80495cd
        puts("Bad host (4)");
        exit(8);
        // UNREACHABLE
    }
    char * v4 = g7[0];
    g2 = 0;
    g4 = str2;
    g3 = 0x804a700;
    if (v4 == NULL) {
        // 0x8049625
        puts("Bad host (5).");
        exit(8);
        // UNREACHABLE
    }
    int32_t str = (int32_t)v4; // 0x80495e9
    while (true) {
        // 0x80495e5
        if (strcasecmp((char *)str, (char *)str2) == 0) {
            // 0x8049601
            open_clientfd();
            close(0);
            g2 = v3;
            g4 = v2;
            g3 = v1;
            return;
        }
        // 0x80495f5
        g2++;
        char * v5 = g7[0]; // 0x80495f8
        if (v5 == NULL) {
            // 0x8049625
            puts("Bad host (5).");
            exit(8);
            // UNREACHABLE
        }
        // 0x80495f5
        str2 = g4;
        str = (int32_t)v5;
        // branch -> 0x80495e5
    }
}

// --------------- Dynamically Linked Functions ---------------

// void __ctype_b_loc(void);
// void bcopy(const void *, void *, size_t);
// int close(int);
// int connect(int, const struct sockaddr *, socklen_t);
// __caddr_t cuserid(__caddr_t __buf);
// int dup(int fildes);
// void exit(int);
// int fclose(FILE *);
// int fflush(FILE *);
// char * fgets(char *restrict, int, FILE *restrict);
// FILE * fopen(const char *restrict, const char *restrict);
// int fprintf(FILE *restrict, const char *restrict, ...);
// int fputc(int, FILE *);
// size_t fwrite(const void *restrict, size_t, size_t, FILE *restrict);
// char * getenv(const char *);
// struct hostent *gethostbyname(const char *);
// int gethostname(__caddr_t __name);
// int printf(const char *restrict, ...);
// int puts(const char *);
// void rewind(FILE *);
// sighandler_t signal(int signum, sighandler_t handler);
// unsigned int sleep(unsigned int seconds);
// int socket(int domain, int type, int protocol);
// int sprintf(char *restrict, const char *restrict, ...);
// int sscanf(const char *restrict, const char *restrict, ...);
// int strcasecmp(const char *, const char *);
// char * strcpy(char *restrict, const char *restrict);
// long strtol(const char *restrict, char **restrict, int);
// int system(const char *);
// FILE * tmpfile();

// --------------- Instruction-Idiom Functions ----------------

// int32_t strlen(char * a1);

// --------------------- Meta-Information ---------------------

// Detected compiler/packer: gcc (4.4.7)
// Detected language: C
// Detected functions: 23
// Decompiler release: v2.1.1.1 (2015-11-18)
// Decompilation date: 2015-12-01 21:34:20
